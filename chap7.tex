% chap7.tex - Week 7
\cleardoublepage
%\phantomsection
\chapter{Week 7}

How to collab, pushing, rebasing, merging, patches

\section{Day 1 - ``Networking with a difference''}
\subsection{Pushing across a LAN}

Now we have a complete copy of our repository in another location.  At the moment we have created this clone on the same machine that our original is.  This isn't really a very good idea for backup purposes.  Git supplies several means with which to talk to a remote machine, but by far the most common of these is to utilise the SSH protocol.  SSH is a secure, encrypted way to communicate with a remote repository.  Which is a must for pushing to an important repository that people are going to pull information from.

If we assume that for a moment that our user \emph{john} has now moved to another machine and now wishes to clone a repository that he had on his original machine to this new one.  The commands are identical to that which we used before.  We are going to assume that \emph{john} already has SSH access to the machine.  In this way, we can issue the commands as follows.

\begin{Verbatim}
john@akira:~$ git clone ssh://john@satsuki/home/john/coderepo coderepo-ne
Initialized empty Git repository in /home/john/coderepo-ne/.git/
john@akira's password: 
remote: Counting objects: 53, done.
remote: Compressing objects: 100% (36/36), done.
Receiving objects: 100% (53/53), 4.84 KiB, done.
Resolving deltas: 100% (10/10), done.
remote: Total 53 (delta 10), reused 0 (delta 0)
john@akira:~$ 
\end{Verbatim}

Now we have done exactly as before and cloned our repository to a local folder called \texttt{coderepo-ne} from the remote url \texttt{ssh://john@satsuki/home/john/coderepo}.  Notice the use of \texttt{ssh://} to denote the specification of the SSH protocol.  We have also put the users name in the url of the remote path.  If the SSH server was running on a different port to usual, that is, on a port other than 22, we could have also added a port number preceeded by a colon after the hostname.

SSH isn't the only protocol that Git can use.  We have already looked at two; local and SSH.  In fact, Git supports a further two protocols and these are HTTP/S and Git's own GIT protocol.  We are going to take a quick look at the Git protocol next, before moving on to HTTP/S.

\subsection{The Git Protocol}
The GIT protocol is the fastest transfer protocol out there for Git repositories.  This should come as no surprise, since it was developed exclusively for use within a Git environment.  It does however have a relatively large drawback.  The drawback is that it provides absolutely no authentication.  For this reason, enabling the GIT protocol on a repository and running the server backend, (described later), will allow anyone who can talk to the servers port complete read access to the repository.

If you are serving a large repository on the Internet for example, this could actually be rather beneficial and will allow you to serve pulls quickly and efficiently.  However, though it is possible to enable \emph{pushing} using the GIT protocol, the lack of security would mean that anyone who could see the server and connect to the port, usually 9418, could make changes to the repository.  This is usually entirely undesirable and as such people will often couple a read-only GIT protocol with a writable SSH protocol for the developers that need push access.

\subsection{The HTTP/S Protocol}
Just as with the GIT protocol, Git can support the HTTP/HTTPS protocol as well.  Setting up this is usually as simple as creating a bare clone of your repository, keeping it up to date, usually via a post-update-hook, which is described later in the book, and simply allowing clients access to this server area.  

Note that the above is only to provide read-only access over HTTP.  It is possible to allow writable access, ie pushing, over HTTPS, but this is more complicated to set up and is outside the scope of this book.

\subsection{Protocol decision}
Tamagoyaki are about to embark on their decision making process regarding which protocols to use and how to perform their collaboration between themselves and their external partners.  They are going to have to take multiple things into consideration, such as security, speed, administration and storage.  When you begin to implement the Git system yourself, you too will have to think about these decisions and answer questions like:

\begin{itemize}
\item Who is going to require access to the repository?
\item How many people are going to require access to the repository?
\item Is the information sensitive, either from an IP perspective or from a customer point of view?
\item How large is the data that we are hosting?
\item How large is the change set?
\item Do we need a QA area?
\item Do we need a Production area?
\end{itemize}

This is just a short list of the questions that you will need to consider when implementing a full on Git environment.  The beauty of the Git system though, is that it is flexible and very difficult to box yourself into a corner, where a decision made early on prohibits a different approach later on.

\section{Day 2 - ``Now let's work together''}
\subsection{Pure collaboration}

We are now armed with a much clearer idea of how Git works and indeed we are now in a position to actually implement the developmental model that the team of Tamagoyaki need in order to collaborate on their projects.  It should be noted that although we have reached the point of being able to work together on a project, this is not where out discussions about Git will end.  We still have a number of topics to cover and these will be visited as required during the subsequent implementation of Git at Tamagoyaki.

\begin{trenches}
``So I still maintain that we follow the original plan,'' said Rob.  ``Each person has their own repository and is the master of their own commits''

John shook his head.  ``On a small scale,'' he began, ``that might work.''  He paused for a breath.  ``But we need to think about scalability too.  Whilst I don't think all development work should be in one repository, I also don't think the best way to go is to have a repo for every person.''

``I know it's a rarity, but I gotta agree with John.''  Klaus spoke whilst idly stabbing his pen lighty into a blob of what looked like modelling clay.  ``Think what the chimp would say to it too.''

Martha furrowed her brow, ``The chimp?'' she asked.

John turned to look at Martha and almost regretted having to inform her of yet another of Klaus' pet names.  ``That's what Klaus calls Jimmy in IT.''  

Martha looked a little horrified, ``Klaus, that's an awful thing to say.''  

``What?  He spends all day monkeying around in the 'datacenter'.  I've never really seen him do any work at all.''  Klaus was looking at Martha now with one eyebrow raised.  He had used airquotes when voicing the word 'datacenter'.  ``Plus he calls it a datacenter, but I've seen inside, it's more like a cupboard with a PC in it.''

``You need to show a little more respect Klaus,'' Martha threw back, a little more agressively than she had intended.

``Guys!! Guys!!''  John shouted.  ``Can we get back to the topic at hand and deal with Klaus later?''

The room fell silent for a while, until the comments had transitioned for immediate to short term memory.  ``How about doing it by team?''  It was Eugene.  ``You know, kinda like a Mob repository.  Each team will have their own repository and the branches inside will belong to the different team members and be named accordingly so.  Then we would have a company repository which would hold the projects and would have dev, qa and released branches.''

``You know that's not a bad idea Eugene.''  Klaus said, trying to redeem himself.  ``You da man.  How about a hi-five.''

\end{trenches}

The idea of having a Mob repository is not anything new.  Many people decide to split up their teams in this way especially within a company.  For larger repositories it makes a lot of sense as not only does it help to keep development altogether in one place, but it also saves on space and administration overhead.  Managing many smaller repositories is often a lot more time consuming than managing several larger ones.  

However you should always look at the situation and the scenario carefully to see which is going to suit you best.  For Tamagoyaki, there is the prospect of the teams growing soon and so they require a way to get the data organised fairly quickly and effortlessly.  Having many small repositories would likely confuse new members to the team, so the decision to move forward with team based and site based repositories makes sense.

Tamagoyaki are proposing to have a single repository which will be the \emph{blessed} repository we discussed way back at the beginning of the book.  This repository will likely hold three branches.  These will relate to development, quality assurance and released.  To this end it will allow other teams to gain access to features that the other teams are working on, through the development branch.  It will allow a QA manager to work on the quality assurance branch and finally, it will allow someone to push these changes through to the released branch.  

The idea is that all development work stays in the development branch.  For Tamagoyaki Inc. this branch will likely contain mostly finished, but largely untested works.  The teams will work together inside their mob repositories to create new functionality.  Once they are happy, their team leader will push their changes up into the development branch on the \emph{blessed} repository.  This branch is not gauranteed to be stable.  Sometimes things will break but the development branch is a place that all of the work of the various teams comes together.  

Once the teams hit feature freeze, the point at which they will no longer take any more new features into the code base, they will ask the QA manager to create a \textbf{QA} branch.  Bug fixes for current issues will be committed here and when all bugs have been fixed and the code is ready to be released, the release branch will be synced with a specific commit of the \textbf{QA} branch.  

If this all sounds a little confusing, we will take a few minutes to digest what we have come up with and draw a few diagrams.  The beauty of Git is that it is so configurable and supports almost limitless workflows.  Unfortunately this can also be a drawback because no two Git setups are generally alike.  The set up of Git is totally customised to the situation or scenario at hand.  In our case, we have merged together two of the workflow models that we presented in the early chapters.

We are using a \emph{blessed} repository with which to store our crown jewels.  This is the repository that contains our main \textbf{release} branch.  This branch will always contain reliable stable releases.  Sure it may contain history of how we reached the stable release, but on a checkout, it will be a solid, buildable, pristine release.  This repository also contains our \textbf{QA} branch.  This is the branch that upon checkout would contain a fairly polished version of the product, but it may still have a few bugs and issues.  Then we have our development branch.  This is where the integration managers from the various teams would pull the code from their teams into a single code base, ready for the QA manager to begin his testing.  This setup may not work for you.  You may require more levels, you may require less.  The fact of the matter is that Git allows you to make that distinction.  

For the developers, we have the team mob repositories.  These repositories will contain multiple branches that the various team members will push to, so that the integration managers are able to pull those changes into the \textbf{dev} branch on the \emph{blessed} repository.

One item we have not yet touched upon is how to bring changes in from one branch to another.  We have one method which we met earlier, called \emph{Merging}.  However there are other options open to us, such as patching and rebasing.  Why are they important you might ask?  Sometimes merging is not the best way to approach the situation.  

\begin{trenches}
John was beginning to get a little frustrated now.  Some members of the team were clearly not understanding what he was saying and he was fighting hard not to raise his voice.  ``It is just messy for me to review is all I am saying.  I would much prefer not to have to see all those merge commits in the history when you are developing a simple feature.''

``We could always look at using a rebase.''  Martha seemed anxious to calm John down.  ``I haven't really played with it enough yet, but rebase could be what we are looking for.''

``What does rebase do when it's at home.''  Sneered Klaus, rolling his eyes.

Martha picked up the red board pen from the board room table and gingerly took off the lid.  She walked over to the whiteboard.  ``For small topics or features,'' she began, ``where you are not going to have to publish it, it would make sense to use rebase.''  She began drawing little diagrams with circles on the board.  ``Rebasing will allow you to take your branch, pick up all the development you have done, update the branch underneath to bring it inline with your blessed dev branch for example, and then replay your development on top.''

``Won't that change your history?  Isn't that a big big no no?''

``Yes it will change your history, and that's why for somethings it isn't appropriate.  But it may be just the ticket for what we are trying to do.''

John smiled.  He was beginning to feel like the team members were starting to embrace Git's potential. 
\end{trenches}

As you know, each time you merge you create a merge commit.  Whilst this is not a problem, it can leave the tree looking messy.  If you are working on a small feature in a branch, and you want to get the latest features and updates from the dev branch, but you do not want the hastle and untidyness of generating a ton of merge commits.  The best way to get round this is to use the rebase tool.

As Martha mentioned, the rebase tool can find a common ancestor between two branches, pick up the new commits on your new branch, update the branch underneath and the replay your commits on top.  Figure 1 below demonstrates this.
